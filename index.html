<!doctype html>
<html lang="en">

<head>
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
   <meta name="generator" content="pdoc 0.10.0" />
   <title>Documentation du système RSA</title>
   <meta name="description" content="" />
   <link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
   <link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
   <link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
   <style>
      :root {
         --highlight-color: #fe9
      }

      .flex {
         display: flex !important
      }

      body {
         line-height: 1.5em
      }

      #content {
         padding: 20px
      }

      #sidebar {
         padding: 30px;
         overflow: hidden
      }

      #sidebar>*:last-child {
         margin-bottom: 2cm
      }

      .http-server-breadcrumbs {
         font-size: 130%;
         margin: 0 0 15px 0
      }

      #footer {
         font-size: .75em;
         padding: 5px 30px;
         border-top: 1px solid #ddd;
         text-align: right
      }

      #footer p {
         margin: 0 0 0 1em;
         display: inline-block
      }

      #footer p:last-child {
         margin-right: 30px
      }

      h1,
      h2,
      h3,
      h4,
      h5 {
         font-weight: 300
      }

      h1 {
         font-size: 2.5em;
         line-height: 1.1em
      }

      h2 {
         font-size: 1.75em;
         margin: 1em 0 .50em 0
      }

      h3 {
         font-size: 1.4em;
         margin: 25px 0 10px 0
      }

      h4 {
         margin: 0;
         font-size: 105%
      }

      h1:target,
      h2:target,
      h3:target,
      h4:target,
      h5:target,
      h6:target {
         background: var(--highlight-color);
         padding: .2em 0
      }

      a {
         color: #058;
         text-decoration: none;
         transition: color .3s ease-in-out
      }

      a:hover {
         color: #e82
      }

      .title code {
         font-weight: bold
      }

      h2[id^="header-"] {
         margin-top: 2em
      }

      .ident {
         color: #900
      }

      pre code {
         background: #f8f8f8;
         font-size: .8em;
         line-height: 1.4em
      }

      code {
         background: #f2f2f1;
         padding: 1px 4px;
         overflow-wrap: break-word
      }

      h1 code {
         background: transparent
      }

      pre {
         background: #f8f8f8;
         border: 0;
         border-top: 1px solid #ccc;
         border-bottom: 1px solid #ccc;
         margin: 1em 0;
         padding: 1ex
      }

      #http-server-module-list {
         display: flex;
         flex-flow: column
      }

      #http-server-module-list div {
         display: flex
      }

      #http-server-module-list dt {
         min-width: 10%
      }

      #http-server-module-list p {
         margin-top: 0
      }

      .toc ul,
      #index {
         list-style-type: none;
         margin: 0;
         padding: 0
      }

      #index code {
         background: transparent
      }

      #index h3 {
         border-bottom: 1px solid #ddd
      }

      #index ul {
         padding: 0
      }

      #index h4 {
         margin-top: .6em;
         font-weight: bold
      }

      @media (min-width:200ex) {
         #index .two-column {
            column-count: 2
         }
      }

      @media (min-width:300ex) {
         #index .two-column {
            column-count: 3
         }
      }

      dl {
         margin-bottom: 2em
      }

      dl dl:last-child {
         margin-bottom: 4em
      }

      dd {
         margin: 0 0 1em 3em
      }

      #header-classes+dl>dd {
         margin-bottom: 3em
      }

      dd dd {
         margin-left: 2em
      }

      dd p {
         margin: 10px 0
      }

      .name {
         background: #eee;
         font-weight: bold;
         font-size: .85em;
         padding: 5px 10px;
         display: inline-block;
         min-width: 40%
      }

      .name:hover {
         background: #e0e0e0
      }

      dt:target .name {
         background: var(--highlight-color)
      }

      .name>span:first-child {
         white-space: nowrap
      }

      .name.class>span:nth-child(2) {
         margin-left: .4em
      }

      .inherited {
         color: #999;
         border-left: 5px solid #eee;
         padding-left: 1em
      }

      .inheritance em {
         font-style: normal;
         font-weight: bold
      }

      .desc h2 {
         font-weight: 400;
         font-size: 1.25em
      }

      .desc h3 {
         font-size: 1em
      }

      .desc dt code {
         background: inherit
      }

      .source summary,
      .git-link-div {
         color: #666;
         text-align: right;
         font-weight: 400;
         font-size: .8em;
         text-transform: uppercase
      }

      .source summary>* {
         white-space: nowrap;
         cursor: pointer
      }

      .git-link {
         color: inherit;
         margin-left: 1em
      }

      .source pre {
         max-height: 500px;
         overflow: auto;
         margin: 0
      }

      .source pre code {
         font-size: 12px;
         overflow: visible
      }

      .hlist {
         list-style: none
      }

      .hlist li {
         display: inline
      }

      .hlist li:after {
         content: ',\2002'
      }

      .hlist li:last-child:after {
         content: none
      }

      .hlist .hlist {
         display: inline;
         padding-left: 1em
      }

      img {
         max-width: 100%
      }

      td {
         padding: 0 .5em
      }

      .admonition {
         padding: .1em .5em;
         margin-bottom: 1em
      }

      .admonition-title {
         font-weight: bold
      }

      .admonition.note,
      .admonition.info,
      .admonition.important {
         background: #aef
      }

      .admonition.todo,
      .admonition.versionadded,
      .admonition.tip,
      .admonition.hint {
         background: #dfd
      }

      .admonition.warning,
      .admonition.versionchanged,
      .admonition.deprecated {
         background: #fd4
      }

      .admonition.error,
      .admonition.danger,
      .admonition.caution {
         background: lightpink
      }
   </style>
   <style media="screen and (min-width: 700px)">
      @media screen and (min-width:700px) {
         #sidebar {
            width: 30%;
            height: 100vh;
            overflow: auto;
            position: sticky;
            top: 0
         }

         #content {
            width: 70%;
            max-width: 100ch;
            padding: 3em 4em;
            border-left: 1px solid #ddd
         }

         pre code {
            font-size: 1em
         }

         .item .name {
            font-size: 1em
         }

         main {
            display: flex;
            flex-direction: row-reverse;
            justify-content: flex-end
         }

         .toc ul ul,
         #index ul {
            padding-left: 1.5em
         }

         .toc>ul>li {
            margin-top: .5em
         }
      }
   </style>
   <style media="print">
      @media print {
         #sidebar h1 {
            page-break-before: always
         }

         .source {
            display: none
         }
      }

      @media print {
         * {
            background: transparent !important;
            color: #000 !important;
            box-shadow: none !important;
            text-shadow: none !important
         }

         a[href]:after {
            content: " (" attr(href) ")";
            font-size: 90%
         }

         a[href][title]:after {
            content: none
         }

         abbr[title]:after {
            content: " (" attr(title) ")"
         }

         .ir a:after,
         a[href^="javascript:"]:after,
         a[href^="#"]:after {
            content: ""
         }

         pre,
         blockquote {
            border: 1px solid #999;
            page-break-inside: avoid
         }

         thead {
            display: table-header-group
         }

         tr,
         img {
            page-break-inside: avoid
         }

         img {
            max-width: 100% !important
         }

         @page {
            margin: 0.5cm
         }

         p,
         h2,
         h3 {
            orphans: 3;
            widows: 3
         }

         h1,
         h2,
         h3,
         h4,
         h5,
         h6 {
            page-break-after: avoid
         }
      }
   </style>
   <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
   <script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>

<body>
   <main>
      <article id="content">
         <h1 class="title"><code>DOCUMENTATION DE NOS PROGRAMMES CONCERNANT LE CHIFFREMENT RSA</code></h1>
         <hr>
         <header>
            <h1 class="title">Module <code>cesar_method</code></h1>
         </header>
         <section id="section-intro">
            Cas général:<br>
            On cherche l'indice ASCII de chaque caractère de notre message pour le convertir en l'indice de notre dictionnaire.<br>
            On va ensuite appliqué un décalage à cet indice (modulo la taille de notre dictionnaire)<br>
            <i>indice = ord(char) - (nombre nécessaire à la conversion)<br>
               resultat += chr((indice + décalage) % (taille du dictionnaire))<br></i>
            <details class="source">
               <summary>
                  <span>Montrer le code correspondant</span>
               </summary>
               <pre><code class="python"># Création d&#39;un dictionnaire de l&#39;ensemble de nos caractères
dictionnaire = []
# Ponctuation
for code in range(33, 48):
    dictionnaire.append(chr(code))
dictionnaire.append(&#34;:&#34;)
dictionnaire.append(&#34;;&#34;)
dictionnaire.append(&#34;?&#34;)
# Lettres majuscules
for code in range(65, 91):
    dictionnaire.append(chr(code))
# Lettres minuscules
for code in range(97, 123):
    dictionnaire.append(chr(code))
# Le caractère espace
dictionnaire.append(&#34; &#34;)
# Les accents
dictionnaire.append(&#34;é&#34;)
dictionnaire.append(&#34;è&#34;)
dictionnaire.append(&#34;à&#34;)


# Codage chiffrement de César (par décalage)

def chiffrement_cesar(texte, décalage):
    resultat = &#34;&#34;
    # Parcours les caractères du message
    for char in texte:
        resultat += dictionnaire[
            (dictionnaire.index(char) + décalage) % len(dictionnaire)
        ]
    return resultat


def dechiffrement_cesar(message):
    # On va tester toutes les valeurs de décalage
    for decalage in range(len(dictionnaire)):
        resultat = &#34;&#34;
        for lettre in message:
            resultat += dictionnaire[
                (dictionnaire.index(lettre) + decalage) % len(dictionnaire)
            ]
        print(decalage, &#34;-&#34;, resultat)
      </code></pre>
            </details>
         </section>
         <section>
         </section>
         <section>
         </section>
         <section>
            <h2 class="section-title" id="header-functions-1">Fonctions du chiffrement de César</h2>
            <dl>
               <dt id="cesar_method.chiffrement_cesar"><code class="name flex">
<span>def <span class="ident">chiffrement_cesar</span></span>(<span>texte, décalage)</span>
</code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Chiffrement d'un message par la méthode de César</b></p>
                     <p>Nous nous interessons ici à la méthode de chiffrement dites "de César" ou par décalage.<br>
                        Le rapport du projet détaille un peu plus son fonctionnement.<br>
                        Nous choisissons simplement un texte et un décalage et la fonction va décaler tous les caractères dans le dictionnaire de la valeur du décalage.<br>
                        Dans cette fonction, nous utilisons un dictionnaire créé par nous-même et nous n'utilisons ni le code ASCII ni aucun autre protocole pour convertir des caractères car l'interet de ce chiffrement ne réside pas là.<br>
                        La fonction va prendre tous les caractères du message à coder, va lui attribuer un nombre (sa place dans le dictionnaire prédéfini) et lui rajouter le décalage souhaité.<br>
                        Tous les codes des caractères auront donc le même décalage et seront ensuite reconverti à travers le dictionnaire en un caractère.</p>
                     <p><b>Args :</b><br>
                        décalage (<i>int</i>): sera le nombre entier qui nous servira de décalage (ex: si égal à 10, la 1ère lettre deviendra la 11ème.)<br>
                        texte (<i>str</i>): sera la chaine de caractères que nous voudrons coder</p>
                     <p><b>Returns :</b><br>
                        <i>str</i> : La chaine de caractère décalé (le message codé)
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def chiffrement_cesar(texte, décalage):
    resultat = &#34;&#34;
    # Parcours les caractères du message
    for char in texte:
        resultat += dictionnaire[
            (dictionnaire.index(char) + décalage) % len(dictionnaire)
        ]
    return resultat</code></pre>
                  </details>
               </dd>
               <dt id="cesar_method.dechiffrement_cesar"><code class="name flex">
<span>def <span class="ident">dechiffrement_cesar</span></span>(<span>message)</span>
</code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Déchiffrement d'un message codé par la méthode de César</b></p>
                     <p>Cette fonction est une fonction "pirate" qui va permettre de déchiffrer un message codé par le chiffrement par décalage même sans connaitre la valeur du décalage en question (qui est notre clé de chiffrement).<br>
                        Nous savons que l'alphabet français est constitué de 26 lettres. Le décalage ne pourra donc avoir que 25 valeurs (le décalage est forcément modulé par 26, ex: un décalage de 1 est pareil qu'un décalage de 27).<br>
                        Dans notre cas, le dictionnaire est modifié et est plus grand que 26 caractères donc nous avons autant de décalage possible que de caractères dans notre dictionnaire.<br>
                        Nous allons donc essayer tous les décalages possibles (il n'y en a pas beaucoup et c'est très rapide) et regarder celui qui nous donne un résultat cohérent.<br>
                        Avec un message chiffré en entrée, nous avons tous les décalages possibiles qui vont sortir de cette fonction mais un seul correspondra à notre message déchiffré.</p>
                     <p><b>Args :</b><br>
                        message (<i>str</i>): sera le message chiffré que le pirate aura récéptionné et tentera de dechiffrer</p>
                     <p><b>Returns :</b><br>
                        <i>None</i> : La fonction ne retourne rien. C'est un choix que nous avons fait pour que le programme principal soit plus interactif, il affiche simplement tous les résultats qu'il a obtenu en testant tous les décalages. Nous aurions très bien pu renvoyer une liste contenant ces possibilités.
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def dechiffrement_cesar(message):
    # On va tester toutes les valeurs de décalage
    for decalage in range(len(dictionnaire)):
        resultat = &#34;&#34;
        for lettre in message:
            resultat += dictionnaire[
                (dictionnaire.index(lettre) + decalage) % len(dictionnaire)
            ]
        print(decalage, &#34;-&#34;, resultat)</code></pre>
                  </details>
               </dd>
            </dl>
         </section>
         <section>
         </section>
         <hr>
         <header>
            <h1 class="title">Module <code>outils_crypto</code></h1>
         </header>
         <section id="section-intro">
            <details class="source">
               <summary>
                  <span>Montrer le code correspondant</span>
               </summary>
               <pre><code class="python">def fichier_vers_texte(fichier):
    return open(fichier).readlines()[0]
            
            
def texte_vers_fichier(texte, fichier):
    open(fichier, &#34;w+&#34;).write(texte)
            
            
def texte_vers_liste(texte):
    Liste = []
    for i in texte:
        temp = str(ord(i))
        if len(temp) &lt; 3:
            temp = &#34;0&#34; + temp
        Liste.append(int(temp[0]))
        Liste.append(int(temp[1]))
        Liste.append(int(temp[2]))
    return Liste
            
            
def liste_vers_texte(Liste):
   texte = &#34;&#34;
   for i in range(0, len(Liste), 3):
      caractère = int(str(Liste[i]) + str(Liste[i + 1]) + str(Liste[i + 2]))
      texte += chr(caractère)
   return texte
            
   
def reconstruit(L):
   new = []
   for i in range(len(L)):
      new.extend(L[i])
   return new
                
                
def decoupage(L, taille):
   sub = len(L) / taille  # le nombre de division
   if int(sub) != sub:
      b = taille - (len(L) % taille)  # nombre de 0 à rajouter
      sub = int(sub) + 1
      for i in range(b):
         L = [0] + L
   new = []
   for i in range(0, len(L), taille):  # décomposition dans une liste
      new.append(L[i : i + taille])
   return new</code></pre>
            </details>
         </section>
         <section>
         </section>
         <section>
         </section>
         <section>
            <h2 class="section-title" id="header-functions-2">Fonctions-outils de notre système RSA</h2>
            <dl>
               <dt id="outils_crypto.fichier_vers_texte"><code class="name flex">
            <span>def <span class="ident">fichier_vers_texte</span></span>(<span>fichier)</span>
            </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Récupération des caractères d'un fichier dans une chaine de caractères</b></p>
                     <p>Cette fonction va nous permettre de récupérer les clés contenues dans des fichiers mais également les messages qu'ils soient chiffrés ou non.<br>
                        Les clés sont codés dans un format spécial (normalisé) mais cette fonction va uniquement nous permettre de récupérer la clé comme chaine de caractères.<br>
                        Concernant les message, cela va nous permettre de récupérer l'intégralité d'un message contenu dans un fichier pour le mettre dans une chaine de caractère.</p>
                     <p><b>Args :</b><br>
                        fichier (<i>file</i>): sera le fichier contenant la clé</p>
                     <p><b>Returns :</b><br>
                        <i>str</i> : Le contenu du fichier converti en chaine de caractères.
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def fichier_vers_texte(fichier):
   return open(fichier).readlines()[0]</code></pre>
                  </details>
               </dd>
               <dt id="outils_crypto.liste_vers_texte"><code class="name flex">
            <span>def <span class="ident">liste_vers_texte</span></span>(<span>Liste)</span>
            </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Transformation d'une liste en chaine de caractères</b></p>
                     <p>Cette fonction nous sert au moment de décoder un message, une fois que nous avons une liste contenant tout les chiffres d'un codage ASCII.<br>
                        Cette fonction est l'inverse de la précédente : <a title="outils_crypto.texte_liste" href="#outils_crypto.texte_vers_liste">texte_vers_liste</a>. Nous allons récupérer et convertir notre chaine de caractères codé en ASCII en la chaine de caractère correspondante.</p>
                     <p><b>Args :</b><br>
                        Liste (<i>liste</i>): sera la liste contenant le message décodé par sa représentations ASCII (où chaque nombre de cette représentation est un élémént de la liste).</p>
                     <p><b>Returns :</b><br>
                        <i>str</i> : La fonction nous renvoie donc la chaine de caractère correspondand au code ASCII décodé contenu dans la liste d'entrée.
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def liste_vers_texte(Liste):
   texte = &#34;&#34;
   for i in range(0, len(Liste), 3):
      caractère = int(str(Liste[i]) + str(Liste[i + 1]) + str(Liste[i + 2]))
      texte += chr(caractère)
   return texte</code></pre>
                  </details>
               </dd>
               <dt id="outils_crypto.texte_vers_fichier"><code class="name flex">
            <span>def <span class="ident">texte_vers_fichier</span></span>(<span>texte, fichier)</span>
            </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Envoi d'une chaine de caractères dans un fichier</b></p>
                     <p>Cette fonction va nous permettre d'écrire dans un fichier déjà existant n'importe quel texte (si le fichier n'existe pas, il sera créé automatiquement).<br>
                        Si nous devons renvoyer une information qui a été modifié par nos fonctions (par exemple le message chiffré ou déchiffré), nous pourrons la réécrire dans un fichier grâce à cette fonction.</p>
                     <p><b>Args :</b><br>
                        texte (<i>str</i>): sera la chaine de caractères contenant l'information que nous voulons exporter<br>
                        fichier (<i>file</i>): sera le fichier où l'on écrira l'information</p>
                     <p><b>Returns :</b><br>
                        <i>None</i>: La fonction ne retourne rien mais modifie directement le fichier
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def texte_vers_fichier(texte, fichier):
   open(fichier, &#34;w+&#34;).write(texte)</code></pre>
                  </details>
               </dd>
               <dt id="outils_crypto.texte_vers_liste"><code class="name flex">
            <span>def <span class="ident">texte_vers_liste</span></span>(<span>texte)</span>
            </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Transformation d'une chaine de caractères en une liste</b></p>
                     <p>Cette fonction est utile une fois que l'on a récupéré une information d'un fichier (dans notre cas un nombre très grand correspondant à notre clé ou bien un message chiffré ou déchiffré).<br>
                        Cette information sous forme de chaine de caractères sera transformée en une liste où chaque élément de la liste correspond à un caractère.<br>
                        Dans notre cas, pour suivre le chiffrement d'information via le protocole RSA, nous avons décidé de récupérer le message contenu dans la chaine de caractères pour convertir chaque caractère du message en son code ASCII (norme informatique du codage de caractères où chaque caractère est lié à un numéro) et le rentrer dans la liste (où chaque chiffre du code ASCII devient donc un élément de la liste ordonnée).</p>
                     <p><b>Args :</b><br>
                        texte (<i>str</i>): sera la chaine de caractères contenant l'information (le message à communiquer)</p>
                     <p><b>Returns :</b><br>
                        <i>list</i> : La fonction renvoie une liste ordonnée contenant le message codé en ASCII par l'ordinateur et où chaque chiffre de ce codage est un élément de la liste.
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def texte_vers_liste(texte):
   Liste = []
   for i in texte:
      temp = str(ord(i))
      if len(temp) &lt; 3:
         temp = &#34;0&#34; + temp
      Liste.append(int(temp[0]))
      Liste.append(int(temp[1]))
      Liste.append(int(temp[2]))
    return Liste</code></pre>
                  </details>
               </dd>
               <dt id="outils_crypto.reconstruit"><code class="name flex">
                  <span>def <span class="ident">reconstruit</span></span>(<span>L)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Réassamblage d'un message découpé</b></p>
                     <p>Cette fonction est utile une fois que l'on a décodé un message mais qu'il a été traité en utilisant des subdivisions de ce message (voir prochaine fonction).<br>
                        Nous allons donc recoller tous les subdivisions une par une dans l'ordre pour obtenir une liste où notre message est simplement dans la liste (et n'est plus une liste de liste).</p>
                     <p><b>Args :</b><br>
                        L (<i>list</i>): est une liste de liste comportant notre message subdivisé</p>
                     <p><b>Returns :</b><br>
                        <i>list</i> : une liste n'ayant plus de subdivision mais comportant tous les éléments des précédentes subdivisions dans l'ordre (n'est plus une liste de liste).
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def reconstruit(L):
   new = []
   for i in range(len(L)):
      new.extend(L[i])
   return new</code></pre>
                  </details>
               </dd>
               <dt id="outils_crypto.decoupage"><code class="name flex">
                  <span>def <span class="ident">decoupage</span></span>(<span>L, taille)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Découpage d'un message</b></p>
                     <p>Cette fonction est utile une fois que l'on veut coder ou décoder un message contenu dans un fichier.<br>
                        Nous allons séparer notre message contenu dans une liste en différentes subdivisions de même taille et nous pourrons donc traiter toutes les subdivisions une par une pour limiter le temps de calcul et travailler sur des listes plus petites.</p>
                     <p><b>Args :</b><br>
                        L (<i>list</i>): est la liste à modifier pour la transformer en liste de subdivisions<br>
                        taille (<i>int</i>): est la taille des subdivisions (du nombre d'élément à mettre dans chaque sous-liste)</p>
                     <p><b>Returns :</b><br>
                        <i>list</i> : notre message modifié qui prend la forme d'une liste de subdivisions (une liste de liste).
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def decoupage(L, taille):
   sub = len(L) / taille  # le nombre de division
   if int(sub) != sub:
      b = taille - (len(L) % taille)  # nombre de 0 à rajouter
      sub = int(sub) + 1
      for i in range(b):
         L = [0] + L
   new = []
   for i in range(0, len(L), taille):  # décomposition dans une liste
      new.append(L[i : i + taille])
   return new</code></pre>
                  </details>
               </dd>
            </dl>
         </section>
         <section>
         </section>
         <hr>
         <header>
            <h1 class="title">Module <code>operations_liste</code></h1>
         </header>
         <section id="section-intro">
            <details class="source">
               <summary>
                  <span>Montrer le code correspondant</span>
               </summary>
               <pre><code class="python">from copy import *
from math import *
            
############################################################################################################################
# [------------------------------------------] DEBUT DE NOS FONCTIONS OUTILS [---------------------------------------------]#
############################################################################################################################
            
            
def supprime_zéros(liste):
   if liste == []:
      return liste
   while True:
      if liste[0] == 0 and len(liste) != 1:
         del liste[0]
      else:
         t = False
         return liste
            
            
def nombre_vers_liste(chiffre):
   new = []
   E = 1
   chiffre = int(chiffre)
   while chiffre % E != chiffre:
      E *= 10
      new = [int((chiffre % E) / (E // 10))] + new
   return new
            
            
def change_retenue(L, base=10):
    if len(L) == 0:
        return [1]

    else:
        if L[-1] != (base - 1):
            L[-1] += 1
            return L
        else:
            L[-1] = 0
        return change_retenue(L[:-1], base) + [L[-1]]
            
            
def est_plus_grand(L1, L2):
    L1 = supprime_zéros(L1)
    L2 = supprime_zéros(L2)
    if L1 == L2:
        return True
    if len(L1) &lt; len(L2):
        return False
    elif len(L2) &lt; len(L1):
        return True
    for i in range(len(L1)):
        if L1[i] == L2[i]:
            if i == len(L1) - 1:
                return False
            continue
        elif L1[i] &lt; L2[i]:
            return False
        else:
            return True
    return False
            
            
def passage_binaire(l1):
    L1 = deepcopy(l1)
    res = []
    r = 0
    while L1 != [0] and L1 != [1] and L1 != []:

        l2 = division(L1, [2])
        L1 = l2[0]
        y = l2[1]

        res = y + res

    if L1 == [1]:

        res = [1] + res

    return res
            
            
def PGCD(L1, L2):
    if est_plus_grand(L2, L1):
        L2, L1 = L1, L2

    while L2 != [0]:
        L1, L2 = L2, division(L1, L2)[1]
    return L1
            
            
def liste_vers_nombre(L1):
    chiffre = ""
    for element in L1:
        chiffre += str(element)
    chiffre = int(chiffre)
    return chiffre
            
            
############################################################################################################################
# [--------------------------------------------------] FIN DE NOS OUTILS [-------------------------------------------------]#
############################################################################################################################
            
############################################################################################################################
# [-----------------------------------------] DEBUT DE NOS FONCTIONS OPERATIONS[-------------------------------------------]#
############################################################################################################################
            
            
def addition(L1, L2, base=10):
    if len(L1) &lt; len(L2):
        L1, L2 = L2, L1
    taille1 = len(L1)
    taille2 = len(L2)
    new = []
    supplementaire = []
    min_taille = min(taille1, taille2)
    retenue = 0

    for i in range(min_taille):
        if L1[taille1 - 1 - i] + L2[taille2 - 1 - i] + retenue &lt; base:
            new = [L1[taille1 - 1 - i] + L2[taille2 - 1 - i] + retenue] + new
            retenue = 0
        else:
            new = [L1[taille1 - 1 - i] + L2[taille2 - 1 - i] + retenue - base] + new
            retenue = 1
    if taille1 == taille2 and retenue == 1:
        new = [1] + new
        retenue = 0
    if taille1 != taille2:
        if retenue == 1:
            supplementaire = change_retenue(L1[: (taille1 - taille2)])
        else:
            supplementaire = L1[: (taille1 - taille2)]
        new = supplementaire + new
    return new
            
            
def soustraction(l1, l2, base=10):
    L1 = deepcopy(l1)
    L2 = deepcopy(l2)

    if est_plus_grand(L2, L1):
        L1, L2 = L2, L1
    taille1 = len(L1)
    taille2 = len(L2)
    new = []
    compteur = 0
    for i in range(taille2):
        L2[taille2 - 1 - i] += compteur
        if L1[taille1 - 1 - i] - L2[taille2 - 1 - i] &lt; 0:
            compteur = 1
            new = [base + L1[taille1 - 1 - i] - L2[taille2 - 1 - i]] + new
        else:
            new = [L1[taille1 - 1 - i] - L2[taille2 - 1 - i]] + new
            compteur = 0
    if compteur == 1:
        L1[taille1 - taille2 - 1] -= 1
    new = L1[: (taille1 - taille2)] + new
    supprime_zéros(new)
    return new
            
            
def multiplication_negative(l1, l2, base=10):
    L1 = deepcopy(l1)
    L2 = deepcopy(l2)
    negatif = False
    if L1[0] == L2[0] == &#34;negatif&#34;:
        L1.remove(&#34;negatif&#34;)
        L2.remove(&#34;negatif&#34;)
    elif L1[0] == &#34;negatif&#34;:
        negatif = True
        L1.remove(&#34;negatif&#34;)
    elif L2[0] == &#34;negatif&#34;:
        negatif = True
        L2.remove(&#34;negatif&#34;)

    resultat = [0]
    if len(L1) == len(L2):
        L1 = [0] + L1
    L1, L2 = max(L1, L2, key=len), min(L1, L2, key=len)
    for i in range(len(L2)):
        for j in range(len(L1)):
            resultat = addition(
                resultat,
                (
                    nombre_vers_liste(L1[len(L1) - j - 1] * L2[len(L2) - i - 1])
                    + [0 for i in range(i + j)]
                ),
                base,
            )
    supprime_zéros(resultat)
    if negatif:
        resultat.insert(0, &#34;negatif&#34;)
    return resultat
            
            
def soustraction_negative(l1, l2, base=10):
    L1 = deepcopy(l1)
    L2 = deepcopy(l2)
    negatif = False
    if L1[0] == L2[0] == &#34;negatif&#34;:
        L1.remove(&#34;negatif&#34;)
        L2.remove(&#34;negatif&#34;)
        return soustraction_negative(L2, L1)
    elif L2[0] == &#34;negatif&#34;:
        L2.remove(&#34;negatif&#34;)
        return addition(L1, L2)
    elif L1[0] == &#34;negatif&#34;:
        L1.remove(&#34;negatif&#34;)
        c = addition(L2, L1)
        c.insert(0, &#34;negatif&#34;)
        return c
    elif est_plus_grand(L2, L1):
        negatif = True
        L1, L2 = L2, L1
    taille1 = len(L1)
    taille2 = len(L2)
    new = []
    compteur = 0
    for i in range(taille2):
        L2[taille2 - 1 - i] += compteur
        if L1[taille1 - 1 - i] - L2[taille2 - 1 - i] &lt; 0:
            compteur = 1
            new = [base + L1[taille1 - 1 - i] - L2[taille2 - 1 - i]] + new
        else:
            new = [L1[taille1 - 1 - i] - L2[taille2 - 1 - i]] + new
            compteur = 0
    if compteur == 1:
        L1[taille1 - taille2 - 1] -= 1
    new = L1[: (taille1 - taille2)] + new
    supprime_zéros(new)

    if negatif:
        new.insert(0, &#34;negatif&#34;)

    return new
            
            
def multiplication(L1, L2, base=10):
    resultat = [0]
    if len(L1) == len(L2):
        L1 = [0] + L1
    L1, L2 = max(L1, L2, key=len), min(L1, L2, key=len)
    for i in range(len(L2)):
        for j in range(len(L1)):
            resultat = addition(
                resultat,
                (
                    nombre_vers_liste(L1[len(L1) - j - 1] * L2[len(L2) - i - 1])
                    + [0 for i in range(i + j)]
                ),
            )
    return resultat
            
            
def division(l1, l2):
    L1 = deepcopy(l1)
    L2 = deepcopy(l2)
    L1 = supprime_zéros(L1)
    L2 = supprime_zéros(L2)
    Q = []
    restedecoupage = 0
    decoupage = L1[: (len(L2))]
    while est_plus_grand(L1, L2):
        V = [0]
        while est_plus_grand(decoupage, L2):
            decoupage = soustraction(decoupage, L2)
            V = addition([1], V)

        Q = Q + V
        if len(l1) - restedecoupage == len(L2):
            break
        restedecoupage += 1
        decoupage = decoupage + [l1[len(L2) + restedecoupage - 1]]

        if L1 == [0 for i in range(len(L1))]:
            Q += [0 for j in range(len(L1))]
    Q = supprime_zéros(Q)
    decoupage = supprime_zéros(decoupage)
    if decoupage == []:
        decoupage = [0]

    return [Q, decoupage]
            
            
def modulo(L1, modulo):
    x, reste = division(L1, modulo)
    return reste
            
            
def expo_modulaire(l1, exposant, module):
    L1 = deepcopy(l1)
    L1 = supprime_zéros(L1)
    res = [1]
    expobinaire = passage_binaire(exposant)

    for i in range(len(expobinaire) - 1, -1, -1):
        if expobinaire[i] == 1:
            res = multiplication(res, L1)
            res = modulo(res, module)

        L1 = multiplication(L1, L1)
        L1 = modulo(L1, module)

    return res
            
            
def euclide_etendu(L1, L2):
    L = deepcopy(L2)
    echange = False
    if est_plus_grand(L2, L1):
        L2, L1 = L1, L2
        echange = True
    x = [1]
    X = [0]
    y = [0]
    Y = [1]
    while L2 != [0]:
        Q = division(L1, L2)[0]
        L1, L2 = L2, division(L1, L2)[1]
        t = soustraction_negative(x, multiplication_negative(Q, X))
        X, x = t, X
        c = soustraction_negative(y, multiplication_negative(Q, Y))
        Y, y = c, Y
    if echange:
        x, y = y, x

    if x[0] == "negatif":
        x.remove("negatif")
        g = soustraction_negative(L, x)
        x = g
    return L1, x, y  # on a l'égalité pgcd= xL1+yL2  ,l'inverse de  L1 modulo L2 est x</code></pre>
            </details>
         </section>
         <section>
         </section>
         <section>
         </section>
         <section>
            <h2 class="section-title" id="header-functions-3">Opérations</h2>
            <dl>
               <dt id="operations_liste.PGCD"><code class="name flex">
                  <span>def <span class="ident">PGCD</span></span>(<span>L1, L2)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Trouver le PGCD entre 2 listes</b></p>
                     <p>Cette fonction nous permet de trouver le plus grand diviseur commun entre deux listes (correspondant à nos nombres).<br>
                        Nous utilisons pour cela l'algorithme d'Euclide. Cette fonction est développée dans notre rapport de projet.</p>
                     <p><b>Args :</b><br>
                        L1, L2 (<i>list</i>): Les deux listes à comparer pour trouver leur PGCD</p>
                     <p><b>Return :</b><br>
                        <i>list</i> : Le PGCD entre les deux listes en entrée
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def PGCD(L1, L2):
    if est_plus_grand(L2, L1):
        L2, L1 = L1, L2

    while L2 != [0]:
        L1, L2 = L2, division(L1, L2)[1]
    return L1</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.addition"><code class="name flex">
                  <span>def <span class="ident">addition</span></span>(<span>L1, L2, base=10)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Additionne deux listes</b></p>
                     <p>Ceci est notre première opération élémentaire. On souhaite additionner deux listes qui représentent deux nombres.<br>
                        On suppose que L1 est plus grand que L2 et si c'est l'inverse, L2 devient L1 et L1 devient L2.<br>
                        Nous allons ensuite effectuer l'addition sur chaque élément des deux listes avec les mêmes indices (en partant de la fin) et si notre addition des deux éléments est plus grande que la base nous utilisons la fonction change_retenue; sinon, nous faisons l'addition classique des deux éléments.</p>
                     <p><b>Args</b> :<br>
                        L1, L2 (<i>list</i>): Les deux listes à additionner</p>
                     <p><b>Return</b> :<br>
                        <i>list</i> : L'addition des deux listes, elle-aussi sous forme de liste
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def addition(L1, L2, base=10):
    if len(L1) &lt; len(L2):
        L1, L2 = L2, L1
    taille1 = len(L1)
    taille2 = len(L2)
    new = []
    supplementaire = []
    min_taille = min(taille1, taille2)
    retenue = 0

    for i in range(min_taille):
        if L1[taille1 - 1 - i] + L2[taille2 - 1 - i] + retenue &lt; base:
            new = [L1[taille1 - 1 - i] + L2[taille2 - 1 - i] + retenue] + new
            retenue = 0
        else:
            new = [L1[taille1 - 1 - i] + L2[taille2 - 1 - i] + retenue - base] + new
            retenue = 1
    if taille1 == taille2 and retenue == 1:
        new = [1] + new
        retenue = 0
    if taille1 != taille2:
        if retenue == 1:
            supplementaire = change_retenue(L1[: (taille1 - taille2)])
        else:
            supplementaire = L1[: (taille1 - taille2)]
        new = supplementaire + new
    return new</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.change_retenue"><code class="name flex">
                  <span>def <span class="ident">change_retenue</span></span>(<span>L, base=10)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Ajout d'une retenue lors d'une opération</b></p>
                     <p>Cette fonction nous permet de supprimer le problème de retenue sur nos opérations.<br>
                        Elle sera utilisée lors d'une addition, ajoutera un au nombre en entrée (sous forme d'une liste) et traitera le problème potentiel de la retenue sur chaque élément de la liste.</p>
                     <p><b>Args</b> :<br>
                        L (<i>list</i>): notre liste en entrée sur laquelle sera appliquée la retenue<br>
                        base (<i>int</i>): Par défaut 10, permet de changer de base si nous le voulons</p>
                     <p><b>Return</b> :<br>
                        <i>list</i> : renvoie la liste de départ (+1) mais en ajoutant la retenue si nécéssaire
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def change_retenue(L, base=10):
    if len(L) == 0:
        return [1]

    else:
        if L[-1] != (base - 1):
            L[-1] += 1
            return L
        else:
            L[-1] = 0
        return change_retenue(L[:-1], base) + [L[-1]]</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.division"><code class="name flex">
                  <span>def <span class="ident">division</span></span>(<span>l1, l2)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Division de deux listes</b></p>
                     <p>Je tiens tout d'abord à spécifier que c'est un bonheur pour nous de vous présenter cette fonction en vue du temps passé dessus.<br>
                        Je tiens également à féliciter notre groupe pour le sang, la sueur et les larmes qu'il a laissé au travers de ces lignes de code et spécifiquement au travers de cette fonction au bout de laquelle nous avons finalement trouvé un résultat plus que satisfaisant.<br>
                        La logique de cette fonction est légérement différente que les autres car nous n'allons pas commencer par traiter le début du nombre (la fin de la liste) mais nous allons plutôt partir du début de la première liste.<br>
                        Nous allons récupérer le début de la première liste (selon la taille de la seconde liste) et effectuer des soustraction entre la partition de la première liste et la seconde liste. Cela nous permet donc de faire augmenter le quotient.<br>
                        Ensuite, si la partition de L1 doit changer, il ne faut pas oublier de modifier le quotient comment nous augmenter le quotient (qui doit gagner des puissances de 10) selon la nouvelle taille de la partition.</p>
                     <p><b>Args :</b><br>
                        l1, l2 (<i>list</i>): nos deux listes à diviser (nous divisons l1 par l2)</p>
                     <p><b>Return</b> :<br>
                        <i>list</i>: le résultat de notre division qui est une liste de deux listes, le quotient puis le reste
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def division(l1, l2):
    L1 = deepcopy(l1)
    L2 = deepcopy(l2)
    L1 = supprime_zéros(L1)
    L2 = supprime_zéros(L2)
    Q = []
    restedecoupage = 0
    decoupage = L1[: (len(L2))]
    while est_plus_grand(L1, L2):
        V = [0]
        while est_plus_grand(decoupage, L2):
            decoupage = soustraction(decoupage, L2)
            V = addition([1], V)

        Q = Q + V
        if len(l1) - restedecoupage == len(L2):
            break
        restedecoupage += 1
        decoupage = decoupage + [l1[len(L2) + restedecoupage - 1]]

        if L1 == [0 for i in range(len(L1))]:
            Q += [0 for j in range(len(L1))]
    Q = supprime_zéros(Q)
    decoupage = supprime_zéros(decoupage)
    if decoupage == []:
        decoupage = [0]

    return [Q, decoupage]</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.est_plus_grand"><code class="name flex">
                  <span>def <span class="ident">est_plus_grand</span></span>(<span>L1, L2)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Permet de comparer deux listes</b></p>
                     <p>Cette fonction vérifie, chiffre par chiffre dans la liste, si notre première liste est plus grande que la seconde.<br>
                        Cela va nous être utile par la suite lors de différentes opérations.</p>
                     <p><b>Args</b> :<br>
                        L1, L2 (<i>list</i>): nos deux listes à comparer</p>
                     <p><b>Return</b> :<br>
                        <i>Boolean</i> : rend True si L1 est plus grand ou égal à L2 et False sinon
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def est_plus_grand(L1, L2):
    L1 = supprime_zéros(L1)
    L2 = supprime_zéros(L2)
    if L1 == L2:
        return True
    if len(L1) &lt; len(L2):
        return False
    elif len(L2) &lt; len(L1):
        return True
    for i in range(len(L1)):
        if L1[i] == L2[i]:
            if i == len(L1) - 1:
                return False
            continue
        elif L1[i] &lt; L2[i]:
            return False
        else:
            return True
    return False</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.euclide_etendu"><code class="name flex">
                  <span>def <span class="ident">euclide_etendu</span></span>(<span>L1, L2)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Algorithme d'Euclide étendu</b></p>
                     <p>Ce programme est une application directe de l'algorithme d'Euclide étendu, développé dans la partie mathématique du rapport de projet.</p>
                     <p><b>Args</b>:<br>
                        L1, L2 (<i>list</i>): Nos deux listes auxquelles on applique l'algorithme</p>
                     <p><b>Return</b>:<br>
                        <i>list</i>: 3 éléments sont rendus par l'algorithme, le PGCD et les coefficients de Bezout
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def euclide_etendu(L1, L2):
    L = deepcopy(L2)
    echange = False
    if est_plus_grand(L2, L1):
        L2, L1 = L1, L2
        echange = True
    x = [1]
    X = [0]
    y = [0]
    Y = [1]
    while L2 != [0]:
        Q = division(L1, L2)[0]
        L1, L2 = L2, division(L1, L2)[1]
        t = soustraction_negative(x, multiplication_negative(Q, X))
        X, x = t, X
        c = soustraction_negative(y, multiplication_negative(Q, Y))
        Y, y = c, Y
    if echange:
        x, y = y, x

    if x[0] == "negatif":
        x.remove("negatif")
        g = soustraction_negative(L, x)
        x = g
    return L1, x, y  # on a l'égalité pgcd= xL1+yL2  ,l'inverse de  L1 modulo L2 est x</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.expo_modulaire"><code class="name flex">
                  <span>def <span class="ident">expo_modulaire</span></span>(<span>l1, exposant, module)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Mettre un nombre à une puissance et le moduler en même temps</b></p>
                     <p>Dans notre programme RSA, nous devrons mettre notre message à une puissance et y appliquer un modulo. Cependant, faire ces deux opérations de façon disjointe est beaucoup trop long car nous devrions traiter des nombres extrèmement grands.<br>
                        Nous avons donc trouver un moyen de combiner ces deux opérations.<br>
                        Nous passons notre exposant en binaire et nous pouvons donc traiter chaque "bit" de notre exposant indépendamment.<br>
                        La méthode de cette fonction est expliquée en détail dans le rapport de projet et est appuyé par la formule correspondante.</p>
                     <p><b>Args</b>:<br>
                        l1 (<i>list</i>): la liste que nous passerons à l'exposant et modulerons<br>
                        exposant (<i>list</i>): l'exposant que l'on applique à la liste<br>
                        module (<i>list</i>): le module que l'on applique à la liste</p>
                     <p><b>Return</b>:<br>
                        <i>list</i>: le résultat de notre liste en entrée mis à la puissance correspondant à l'exposant puis modulée par notre module
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def expo_modulaire(l1, exposant, module):
    L1 = deepcopy(l1)
    L1 = supprime_zéros(L1)
    res = [1]
    expobinaire = passage_binaire(exposant)

    for i in range(len(expobinaire) - 1, -1, -1):
        if expobinaire[i] == 1:
            res = multiplication(res, L1)
            res = modulo(res, module)

        L1 = multiplication(L1, L1)
        L1 = modulo(L1, module)

    return res</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.liste_vers_nombre"><code class="name flex">
                  <span>def <span class="ident">liste_vers_nombre</span></span>(<span>L1)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Convertir une liste en un nombre</b></p>
                     <p>Durant tout notre système, nous utilisons des listes à la place de nombres pour comprendre comment les programmeurs faisaient pour développer le système RSA lorsque les langages de programmation ne pouvaient pas traiter de grands nombres.<br>
                        Une fois que nous avons effecté tous nos calculs sur des nombres sous la forme de listes, nous pouvons les reconvertir en des nombre (pour que l'affichage soit plus clair) ou bien pour tester nos programmes avec des fonctions natives de Python.<br>
                        Cette fonction nous permet cette convertion.</p>
                     <p><b>Args</b> :<br>
                        L1 (<i>list</i>): La liste à convertir</p>
                     <p><b>Return</b> :<br>
                        <i>int</i> : L'entier correspondant à la liste en entrée
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def liste_vers_nombre(L1):
    chiffre = ""
    for element in L1:
        chiffre += str(element)
    chiffre = int(chiffre)
    return chiffre</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.modulo"><code class="name flex">
                  <span>def <span class="ident">modulo</span></span>(<span>L1, modulo)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Calcul le résultat d'un nombre modulé</b></p>
                     <p>Cette fonction nous renvoie simplement le reste d'une division euclidienne (fonction déjà existante dans nos programmes).</p>
                     <p><b>Args</b> :<br>
                        L1 (<i>list</i>): correspond à la liste à moduler<br>
                        modulo (<i>list</i>): correspond au modulo à appliquer</p>
                     <p><b>Return</b> :<br>
                        <i>list</i> : le reste de la division euclidienne des deux entrées
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def modulo(L1, modulo):
    x, reste = division(L1, modulo)
    return reste</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.multiplication"><code class="name flex">
                  <span>def <span class="ident">multiplication</span></span>(<span>L1, L2, base=10)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Multiplication de deux listes</b></p>
                     <p>Notre fonction multiplication est plutôt simple dans sa conception (ce qui implique malheureusement dans notre cas une compléxité très élevée, comme développé dans le rapport de projet).<br>
                        Nous l'avons faite par intuition et nous n'avons pas cherché à refaire d'algorithme plus rapide (même si nous nous sommes finalement renseignés sur le sujet).<br>
                        Au départ, cela ne nous a pas posé de problèmes mais lorsque nous avons commencé à travailler sur des listes très grandes, cela a rapidement ralenti nos calculs.<br>
                        Nous faisons simplement des additions en boucle, de la même manière qu'en primaire lorsqu'on apprenait à poser des multiplications. Pour chaque élément de la seconde liste on additionne la première avec elle même autant de fois que la valeur de l'élément (en faisant attention aux puissances de 10 selon la position de l'élément de L2 dans sa liste).<br>
                        Cette fonction ne peut traiter que la multiplication d'entiers naturels.</p>
                     <p><b>Args</b> :<br>
                        L1, L2 (<i>list</i>): nos deux listes à multiplier<br>
                        base (<i>int</i>): par défaut 10, sera la base dans laquelle sera faite l'opération</p>
                     <p><b>Return</b> :<br>
                        <i>list</i> : le résultat de notre multiplication
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def multiplication(L1, L2, base=10):
    resultat = [0]
    if len(L1) == len(L2):
        L1 = [0] + L1
    L1, L2 = max(L1, L2, key=len), min(L1, L2, key=len)
    for i in range(len(L2)):
        for j in range(len(L1)):
            resultat = addition(
                resultat,
                (
                    nombre_vers_liste(L1[len(L1) - j - 1] * L2[len(L2) - i - 1])
                    + [0 for i in range(i + j)]
                ),
            )
    return resultat</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.multiplication_negative"><code class="name flex">
                  <span>def <span class="ident">multiplication_negative</span></span>(<span>l1, l2, base=10)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Multiplication de deux listes qui peuvent être négatives</b></p>
                     <p>La fonction nous permet de traiter le cas de deux listes qui peuvent être négatives mais une fois cette particularité traitée, elle fonctionne comme la fonction multiplication classique.<br>
                        Si les deux nombres sont négatifs ou les deux nombres sont positifs alors le résultat sera positif et nous n'avons donc qu'à faire une multiplication classique.<br>
                        Si seulement un des deux nombres est négatif alors le résultat sera négatif et nous devrons faire la multiplication classique puis rajouter le terme "négatif" à l'avant de la liste.<br>
                        Cette fonction sera utile lorsque nous voudrons faire l'algorithme d'Euclide étendu qui nous demande de traiter des nombres négatifs.<br>
                        Le fait d'utiliser la fonction 'supprime_zéros' est essentiel pour l'utilisation de notre fonction en base 2.</p>
                     <p><b>Args</b> :<br>
                        l1, l2 (<i>list</i>): seront nos deux listes à multiplier (potentiellement négatives)<br>
                        base (<i>int</i>): par défaut 10, sera la base dans laquelle sera faite l'opération</p>
                     <p><b>Return</b> :<br>
                        <i>list</i> : une liste représentant le résultat obtenue par la multiplication (qui pourra être négatif, représenté avec une chaine de caractères "négatif" en début de liste)
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def multiplication_negative(l1, l2, base=10):
    L1 = deepcopy(l1)
    L2 = deepcopy(l2)
    negatif = False
    if L1[0] == L2[0] == &#34;negatif&#34;:
        L1.remove(&#34;negatif&#34;)
        L2.remove(&#34;negatif&#34;)
    elif L1[0] == &#34;negatif&#34;:
        negatif = True
        L1.remove(&#34;negatif&#34;)
    elif L2[0] == &#34;negatif&#34;:
        negatif = True
        L2.remove(&#34;negatif&#34;)

    resultat = [0]
    if len(L1) == len(L2):
        L1 = [0] + L1
    L1, L2 = max(L1, L2, key=len), min(L1, L2, key=len)
    for i in range(len(L2)):
        for j in range(len(L1)):
            resultat = addition(
                resultat,
                (
                    nombre_vers_liste(L1[len(L1) - j - 1] * L2[len(L2) - i - 1])
                    + [0 for i in range(i + j)]
                ),
                base,
            )
    supprime_zéros(resultat)
    if negatif:
        resultat.insert(0, &#34;negatif&#34;)
    return resultat</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.nombre_vers_liste"><code class="name flex">
                  <span>def <span class="ident">nombre_vers_liste</span></span>(<span>chiffre)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Transformation d'un nombre en une liste</b></p>
                     <p>Dans nos programmes, nous convertissons les nombres en listes car nous nous placerons dans le cas où le langage n'arrive pas à traiter des nombres très grands directement (par exemple le C lorsque le système RSA est sorti).<br>
                        Cette fonction nous permet de créer une liste qui représentera un nombre où chaque case de la liste représente un chiffre composant le nombre. Tout notre système va utiliser des listes correspondant à des nombres.<br>
                        L'unité sera la dernière case, le chiffre des dizaines sera l'avant-dernière, etc</p>
                     <p><b>Args</b> :<br>
                        chiffre (<i>int</i>): sera le nombre en entier qui pourra être, dans notre cas, très grand</p>
                     <p><b>Return</b> :<br>
                        <i>int</i> : Le nombre converti en liste comme décrit plus haut
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def nombre_vers_liste(chiffre):
   new = []
   E = 1
   chiffre = int(chiffre)
   while chiffre % E != chiffre:
      E *= 10
      new = [int((chiffre % E) / (E // 10))] + new
   return new</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.passage_binaire"><code class="name flex">
                  <span>def <span class="ident">passage_binaire</span></span>(<span>l1)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Convertisseur de la base 10 à la base 2</b></p>
                     <p>Cette fonction convertie la liste correponsant à un nombre en base 10 en une liste correspondant à ce même nombre en base 2.<br>
                        Nous utilisons une technique vu au premier semestre avec M. Prcovic en cours d'informatique: nous effectuons une succession de divisions entières par 2 en notant les restes (qui deviendront notre nombre binaire).</p>
                     <p><b>Args</b> :<br>
                        l1 (<i>list</i>): la liste (en base 10) à convertir</p>
                     <p><b>Return</b> :<br>
                        <i>list</i> : rend la liste convertie en base 2
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def passage_binaire(l1):
    L1 = deepcopy(l1)
    res = []
    r = 0
    while L1 != [0] and L1 != [1] and L1 != []:

        l2 = division(L1, [2])
        L1 = l2[0]
        y = l2[1]

        res = y + res

    if L1 == [1]:

        res = [1] + res

    return res</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.soustraction"><code class="name flex">
                  <span>def <span class="ident">soustraction</span></span>(<span>l1, l2, base=10)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Soustraction entre deux listes</b></p>
                     <p>Voici notre seconde fonction élémentaire. Effectivement, si nous devons additionner pour chiffrer, il est logique de devoir soustraire pour déchiffrer (faire le chemin inverse).<br>
                        Cette fonction rend la valeur absolue de la soustraction de deux listes positives.<br>
                        Cette fonction fonctionne de la manière suivante :<br>
                        Pour chaque élément de nos listes (en partant de la fin de la liste donc du début du nombre), on soustrait les deux éléments entre eux (l'élément de la première liste moins l'élément de la seconde). Si la soustraction est négative, on enlève 1 à la soustraction au prochain indice et on prend la valeur absolue de la soustraction des deux éléments.<br>
                        S'il y a une différence de taille entre la première et la deuxième liste, il nous suffit simplement de rajouter la différence de taille de la première liste au début du résultat.</p>
                     <p><b>Args</b> :<br>
                        l1, l2 (<i>list</i>): nos deux listes à soustraire (l'ordre n'importe pas puisque nous rendons la valeur absolue)<br>
                        base (<i>int</i>): par défaut 10, sera la base dans laquelle sera faite l'opération</p>
                     <p><b>Return</b> :<br>
                        <i>list</i> : la valeur absolue de la soustraction entre les deux listes en entrée
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def soustraction(l1, l2, base=10):
    L1 = deepcopy(l1)
    L2 = deepcopy(l2)

    if est_plus_grand(L2, L1):
        L1, L2 = L2, L1
    taille1 = len(L1)
    taille2 = len(L2)
    new = []
    compteur = 0
    for i in range(taille2):
        L2[taille2 - 1 - i] += compteur
        if L1[taille1 - 1 - i] - L2[taille2 - 1 - i] &lt; 0:
            compteur = 1
            new = [base + L1[taille1 - 1 - i] - L2[taille2 - 1 - i]] + new
        else:
            new = [L1[taille1 - 1 - i] - L2[taille2 - 1 - i]] + new
            compteur = 0
    if compteur == 1:
        L1[taille1 - taille2 - 1] -= 1
    new = L1[: (taille1 - taille2)] + new
    supprime_zéros(new)
    return new</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.soustraction_negative"><code class="name flex">
                  <span>def <span class="ident">soustraction_negative</span></span>(<span>l1, l2, base=10)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Soustraction de deux listes qui peuvent être négatives</b></p>
                     <p>La fonction nous permet de traiter le cas de deux listes qui peuvent être négatives mais une fois cette particularité traitée, elle fonctionne comme la fonction soustraction classique.<br>
                        Si les deux nombres sont négatifs cela revient à faire la soustractions du deuxième par le premier.<br>
                        Si la seconde liste est négative, cela revient à faire l'addition des deux listes.<br>
                        Si la première liste est négative, cela revient à faire l'addition des deux listes est de rajouter la chaine de caractères "negatif" devant le résultat (cela revient à factoriser -1 durant notre calcul).<br>
                        Cette fonction sera utile lorsque nous voudrons faire l'algorithme d'Euclide étendue qui nous demande de traiter des nombres négatifs.<br>
                        Le fait d'utiliser la fonction 'supprime_zéros' est essentielle pour l'utilisation de notre fonction en base 2.</p>
                     <p><b>Args</b> :<br>
                        l1, l2 (<i>list</i>): seront nos deux listes à multiplier (potentiellement négatives)<br>
                        base (<i>int</i>): par défaut 10, sera la base dans laquelle sera faite l'opération</p>
                     <p><b>Return</b> :<br>
                        <i>list</i> : une liste représentant le résultat obtenue par la multiplication (qui pourra être négatif, représenté avec un "négatif" en début de liste)
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def soustraction_negative(l1, l2, base=10):
    L1 = deepcopy(l1)
    L2 = deepcopy(l2)
    negatif = False
    if L1[0] == L2[0] == &#34;negatif&#34;:
        L1.remove(&#34;negatif&#34;)
        L2.remove(&#34;negatif&#34;)
        return soustraction_negative(L2, L1)
    elif L2[0] == &#34;negatif&#34;:
        L2.remove(&#34;negatif&#34;)
        return addition(L1, L2)
    elif L1[0] == &#34;negatif&#34;:
        L1.remove(&#34;negatif&#34;)
        c = addition(L2, L1)
        c.insert(0, &#34;negatif&#34;)
        return c
    elif est_plus_grand(L2, L1):
        negatif = True
        L1, L2 = L2, L1
    taille1 = len(L1)
    taille2 = len(L2)
    new = []
    compteur = 0
    for i in range(taille2):
        L2[taille2 - 1 - i] += compteur
        if L1[taille1 - 1 - i] - L2[taille2 - 1 - i] &lt; 0:
            compteur = 1
            new = [base + L1[taille1 - 1 - i] - L2[taille2 - 1 - i]] + new
        else:
            new = [L1[taille1 - 1 - i] - L2[taille2 - 1 - i]] + new
            compteur = 0
    if compteur == 1:
        L1[taille1 - taille2 - 1] -= 1
    new = L1[: (taille1 - taille2)] + new
    supprime_zéros(new)

    if negatif:
        new.insert(0, &#34;negatif&#34;)

    return new</code></pre>
                  </details>
               </dd>
               <dt id="operations_liste.supprime_zéros"><code class="name flex">
                  <span>def <span class="ident">supprime_zéros</span></span>(<span>liste)</span>
                  </code></dt>
               <dd>
                  <div class="desc">
                     <p><b>Suppression des zéros 'inutiles' à l'avant d'une liste</b></p>
                     <p>Cette fonction modifie la liste en enlevant les zéros inutiles qui se trouvent devant.<br>
                        Cette fonction est essentielle pour nous dans certaine fonction qui ne vont pas fonctionner si des zéros se trouve en début de liste.</p>
                     <p><b>Args</b> :<br>
                        liste (<i>list</i>) : qui sera notre liste de chiffres à corriger</p>
                     <p><b>Return</b> :<br>
                        <i>None</i> : La fonction ne renvoie rien mais modifie directement la liste.<br>
                        (Update) : La fonction renvoie la liste modifiée également (elle continue de modifier la liste initiale car cela prendrait trop de place de faire un deepcopy à chaque fois que l'on appelle cette fonction).
                     </p>
                  </div>
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">def supprime_zéros(liste):
   if liste == []:
      return liste
   while True:
      if liste[0] == 0 and len(liste) != 1:
         del liste[0]
      else:
         t = False
         return liste</code></pre>
                  </details>
               </dd>
               <hr>
               <header>
                  <h1 class="title" id="header-functions-4">Module <code>main_RSA</code></h1>
               </header>
               <section id="section-intro">
                  <h2>Introduction</h2>

                  <p>Cette partie explique l'enchainement des différentes étapes de notre programme pour qu'il fonctionne correctement. Pour plus d'informations concernant les étapes, notre rapport de projet les développe et explique pourquoi nous devons passer pas ces étapes.<br>
                     Tout d'abord, afin d'offrir une plus grande flexibilité d'utilisation, notre programme propose plusieurs options qui sont représentées par les variables texte et clés.<br>

                     texte = True, si on fait le choix d'utiliser des fichiers texte a la place du terminal pour rentrer nos messages et les exporter.<br>
                     clés = True si on fait le choix de choisir l'exposant et les nombres premiers a la place de ceux mis par défaut. En effet des nombres premiers seront mis par défaut pour ne pas que l'utilisateur ne doive en créé à chaque fois mais cela reste possible pour éviter une faille de sécurité évidente.</p>

                  <h2>Choix des nombres premiers et de l'exposant</h2>

                  <p>Tous les nombres doivent être sous forme de liste, les nombres premiers doivent être distincts.</p>
                  <h2>Création des clés</h2>

                  <p>phi_n = (p-1)(q-1) où p et q sont les nombres premiers choisis précédement<br>
                     On fait un test pour savoir si l'exposant est premier avec phi-n, s'il ne l'est pas, le système ne pourra pas fonctionner (cf deuxième partie du rapport de projet) et il faudra donc recommencer.<br>

                     Nous calculons donc ensuite l'inverse de l'exposant modulo phi_n avec l'algorithme d'euclide étendu.<br>

                     Enfin, nous effectuons le passage du texte en liste en utilisant le codage ASCII.</p>

                  <h2>Crytage</h2>

                  <p>- On découpe le message en liste de taille len(n)-1 où n = p*q.<br>
                     - Pour chaque partie ainsi découpée on éxécute l'expo_modulaire avec le decoupage, n et un exposant prédéfini par notre programme.<br>
                     - Notre variable 'rempli' va nous servir à completer la liste obtenue pour qu'elle ait une taille égale à len(n) on obtient une liste de liste qui est le message chiffré que l'on va noter "je_suis_une_étoile"</p>

                  <h2>Création d'un fichier texte avec le message chiffré</h2>

                  <p>On reconstruit nos différentes subdivisions chiffrées en une seule liste chiffrée<br>
                     On passe la liste en chaine de caractères pour pouvoir l'écrire dans un fichier texte (cette instruction ne s'execute que dans le cas ou texte = True )</p>

                  <h2>Récupération de la clé privée</h2>

                  <p>La clé privée est l'inverse de l'exposant modulo phi_n et il faut quelle soit de type list</p>

                  <h2>Récuperation du message chiffré</h2>

                  <p>On récupère le message chiffré contenu dans le fichier message_chiffré.txt puis on le divise en liste de taille len(n) pour obtenir des subdivisions.</p>
                  <h2>Déchiffrement</h2>

                  <p>- On récupére le message "je_suis_une_étoile"<br>
                     - On applique la fonction expo_modulaire avec la clé privée<br>
                     - La variable "remplie" nous sert à compléter la liste obtenue pour qu'elle ait une taille égale à len(n)-1, donc de même taille que la liste avant chiffrement<br>
                     - on reconstruit ensuite la liste <br>
                     - on enlève tous les zeros (de bourage) devant la liste <br>
                     - on se débarrasse de toutes les virgules ex: 1.0 devient 1 (sinon ca devait probablement poser problème à la fonction liste_vers_texte)</p>

                  <h2>Ajout des zeros pouvant manquer pour le passage en code ASCII, en debut du message</h2>

                  <p>Avant de convertir le message dechiffré en texte nous devons traiter les zéros qui sont présents en debut de liste. En effet: le passage du texte en liste se fait en associant à chaque caractère 3 chiffres.Ensuite on découpe le message en liste de taille len(n)-1, si la taille de la liste découpée ne divise pas la taille du message, alors on doit rajouter des zéros au début du message mais alors comment différencier les zéros ajoutés pour le besoin de découpage et ceux ressortant du codage ASCII. La solution est de ne pas s’en préoccuper le long du chiffrement et déchiffrement mais qu’à la fin on supprime tous les zéros. Comme codage ASCCI la taille du message est divisible par 3 on peut ainsi rajouter les zéros manquant (au début du message).
                  <details class="source">
                     <summary>
                        <span>Montrer le code correspondant</span>
                     </summary>
                     <pre><code class="python">from operations_liste import (
    expo_modulaire,
    multiplication,
    nombre_vers_liste,
    supprime_zéros,
    soustraction,
    PGCD,
    euclide_etendue,
    liste_vers_nombre,
)
from outils_crypto import (
    decoupage,
    reconstruit,
    texte_vers_liste,
    liste_vers_texte,
    fichier_vers_texte,
    texte_vers_fichier,
)

texte = False
reponse = input("Voulez-vous utiliser un fichier texte pour le message? [o/N] ")
reponse = reponse.strip().lower()
if reponse.startswith("o"):
    print(
        "OK, vous devez créer un fichier message.txt et y inscire le message à chiffrer sur la première ligne"
    )
    texte = True
elif reponse.startswith("n") or reponse == "":
    print("OK")
else:
    print("Répondez par 'o' ou 'n'")

clés = False
reponse_bis = input("Voulez-vous choisir les nombres premiers et l'exposant? [o/N] ")
reponse_bis = reponse_bis.strip().lower()
if reponse_bis.startswith("o"):
    print("OK")
    clés = True
elif reponse_bis.startswith("n") or reponse_bis == "":
    print("OK")
else:
    print("Répondez par 'o' ou 'n'")

if not texte:
    message_en_texte = input("Entrer le message à chiffrer:")
else:
    message_en_texte = fichier_vers_texte(
        "message.txt"
    )  # nom du fichier contenant le message

# Choix des nombres premiers et de l'exposant

if not clés:  # paramètre par défaut
    nombre_premier1 = nombre_vers_liste(10000005143)
    nombre_premier2 = nombre_vers_liste(10000018097)
    exposant = [7]
else:
    nb1 = int(input("Entrez un 1er nombre premier(un entier): "))
    nb2 = int(input("Entrez un second nombre premier(un entier): "))
    e = int(input("Entrez l'exposant(un entier): "))
    nombre_premier1 = nombre_vers_liste(nb1)
    nombre_premier2 = nombre_vers_liste(nb2)
    exposant = nombre_vers_liste(e)

# Création des cles

phi_n = multiplication(
    soustraction(nombre_premier1, [1]), soustraction(nombre_premier2, [1])
)
if PGCD(exposant, phi_n) != [1]:
    print(
        "e n'est pas premier avec phi_n il faut changer soit l'exposant, soit les nombres premiers"
    )
    exit()
n = multiplication(nombre_premier1, nombre_premier2)
inverse_de_e = euclide_etendue(exposant, phi_n)[1]


message = texte_vers_liste(message_en_texte)


# Crytage

new = decoupage(message, len(n) - 1)  # liste de liste de taille len(n)-1
chiffré_découpé = []
for mes in new:
    ret = expo_modulaire(mes, exposant, n)
    rempli = len(n) - len(ret)  # nombre de zero à rajouter à gauche
    chiffré_découpé.append(
        [0 for i in range(rempli)] + ret
    )  # liste de liste de taille len(n)

chiffré = reconstruit(chiffré_découpé)  # liste de chiffre

# Création d'un fichier texte avec le message chiffré

if texte:
    f_code = ""
    for i in chiffré:
        f_code += str(int(i))
    code = open("message_chiffré.txt", "w")
    code.write(f_code)
    code.close()

print("!!!!:chiffrement terminé:!!!!")

if texte:
    print("le fichier message_chiffré.txt est créé")
else:
    print("message chiffré:", chiffré)

print("voici la clé privée:", liste_vers_nombre(inverse_de_e))

# Clé privé

# clé_privé =inverse_de_e

clé_privé = int(input("entrer la clé privée:"))

if type(clé_privé) == int:
    clé_privé = nombre_vers_liste(clé_privé)
elif type(clé_privé) != list:
    print("erreur type clé privé")

# Récupération du message chiffré

if texte:
    fichier = open("message_chiffré.txt").readlines()[0]

    L = []
    for i in range(len(fichier)):
        L.append(int(fichier[i]))
    chiffré_découpé = decoupage(L, len(n))

# Déchiffrement

print("!!!Debut déchiffrement!!!")

clair = []
for chif in chiffré_découpé:
    res = expo_modulaire(chif, clé_privé, n)
    remplie = len(n) - 1 - len(res)  # permet de rendre des listes de taille len(n)-1
    clair.append([0 for i in range(remplie)] + res)

clair = reconstruit(clair)
clair = supprime_zéros(clair)
message_dechiffré = []
for i in clair:
    message_dechiffré.append(int(i))

# Ajout des zeros pouvant manquer pour le passage en code ASCCI, en debut du message

if len(message_dechiffré) % 3 != 0:
    ajoute0 = 3 * ((len(message_dechiffré) // 3) + 1) - len(message_dechiffré)
    for i in range(ajoute0):
        message_dechiffré = [0] + message_dechiffré

print("!!!Fin du déchiffrement!!!")

# Transforme le message déchiffré en texte

passage_texte = liste_vers_texte(message_dechiffré)

# ouvre le message déchiffré dans un fichier

if texte:
    texte_vers_fichier(passage_texte, "message_déchiffré.txt")
else:
    print("message déchiffré:", passage_texte)

print("FIN DU PROGRAMME")
      </code></pre>
                  </details>
               </section>
               <section>
            </dl>
         </section>
         <section>
         </section>
      </article>
      <nav id="sidebar">
         <h1>Sommaire</h1>
         <div class="toc">
            <ul></ul>
         </div>
         <ul id="index">
            <li>
               <h3><a href="#header-functions-1">Fonctions du chiffrement de César</a></h3>
               <ul class="">
                  <li><code><a title="cesar_method.chiffrement_cesar" href="#cesar_method.chiffrement_cesar">chiffrement_cesar</a></code></li>
                  <li><code><a title="cesar_method.dechiffrement_cesar" href="#cesar_method.dechiffrement_cesar">dechiffrement_cesar</a></code></li>
               </ul>
            </li>
            <li>
               <h3><a href="#header-functions-2">Outils utiles au système RSA</a></h3>
               <ul class="">
                  <li><code><a title="outils_crypto.fichier_vers_texte" href="#outils_crypto.fichier_vers_texte">fichier_vers_texte</a></code></li>
                  <li><code><a title="outils_crypto.liste_vers_texte" href="#outils_crypto.liste_vers_texte">liste_vers_texte</a></code></li>
                  <li><code><a title="outils_crypto.texte_vers_fichier" href="#outils_crypto.texte_vers_fichier">texte_vers_fichier</a></code></li>
                  <li><code><a title="outils_crypto.texte_vers_liste" href="#outils_crypto.texte_vers_liste">texte_vers_liste</a></code></li>
                  <li><code><a title="outils_crypto.reconstruit" href="#outils_crypto.reconstruit">reconstruit</a></code></li>
                  <li><code><a title="outils_crypto.decoupage" href="#outils_crypto.decoupage">decoupage</a></code></li>
               </ul>
            </li>
            <li>
               <h3><a href="#header-functions-3">Opérations sur les listes</a></h3>
               <ul class="">
                  <li><code><a title="operations_liste.PGCD" href="#operations_liste.PGCD">PGCD</a></code></li>
                  <li><code><a title="operations_liste.addition" href="#operations_liste.addition">addition</a></code></li>
                  <li><code><a title="operations_liste.change_retenue" href="#operations_liste.change_retenue">change_retenue</a></code></li>
                  <li><code><a title="operations_liste.division" href="#operations_liste.division">division</a></code></li>
                  <li><code><a title="operations_liste.est_plus_grand" href="#operations_liste.est_plus_grand">est_plus_grand</a></code></li>
                  <li><code><a title="operations_liste.euclide_etendu" href="#operations_liste.euclide_etendu">euclide_etendu</a></code></li>
                  <li><code><a title="operations_liste.expo_modulaire" href="#operations_liste.expo_modulaire">expo_modulaire</a></code></li>
                  <li><code><a title="operations_liste.liste_vers_nombre" href="#operations_liste.liste_vers_nombre">liste_vers_nombre</a></code></li>
                  <li><code><a title="operations_liste.modulo" href="#operations_liste.modulo">modulo</a></code></li>
                  <li><code><a title="operations_liste.multiplication" href="#operations_liste.multiplication">multiplication</a></code></li>
                  <li><code><a title="operations_liste.multiplication_negative" href="#operations_liste.multiplication_negative">multiplication_negative</a></code></li>
                  <li><code><a title="operations_liste.nombre_vers_liste" href="#operations_liste.nombre_vers_liste">nombre_vers_liste</a></code></li>
                  <li><code><a title="operations_liste.passage_binaire" href="#operations_liste.passage_binaire">passage_binaire</a></code></li>
                  <li><code><a title="operations_liste.soustraction" href="#operations_liste.soustraction">soustraction</a></code></li>
                  <li><code><a title="operations_liste.soustraction_negative" href="#operations_liste.soustraction_negative">soustraction_negative</a></code></li>
                  <li><code><a title="operations_liste.supprime_zéros" href="#operations_liste.supprime_zéros">supprime_zéros</a></code></li>
               </ul>
            </li>
            <li>
               <h3><a href="#header-functions-4">Système RSA</a></h3>
               <ul class="">
               </ul>
            </li>
         </ul>
      </nav>
   </main>
   <footer id="footer">
      <p>Otterswiller est le plus beau village au monde. Documentation de tous les programmes utilisés pour le projet : Chiffrement RSA.</p>
   </footer>
</body>

</html>
